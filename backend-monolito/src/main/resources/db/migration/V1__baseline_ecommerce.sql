-- V1__core_baseline.sql
-- Core DB Contract universal para e-commerces (idempotente e OCP-friendly)
-- - Mantém nomes canônicos e apenas expande (sem quebras)
-- - Usa checagens de catálogo e IF NOT EXISTS
-- - Compatível com PostgreSQL 13+ (testado em 18 com Flyway 11.x)

-- ========================================================================
-- 0) EXTENSÕES (preferimos pgcrypto para gen_random_uuid)
-- ========================================================================
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_extension WHERE extname='pgcrypto') THEN
    CREATE EXTENSION pgcrypto;
  END IF;
END$$;

-- ========================================================================
-- 1) AUTORES (cadastro mestre) + UUID estável
-- ========================================================================
CREATE TABLE IF NOT EXISTS payment_author_registry (
  id          BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name        VARCHAR(255) NOT NULL,
  email       VARCHAR(255)
);

-- author_uuid + timestamps (idempotentes)
ALTER TABLE IF EXISTS payment_author_registry
  ADD COLUMN IF NOT EXISTS author_uuid UUID;

ALTER TABLE IF EXISTS payment_author_registry
  ADD COLUMN IF NOT EXISTS created_at TIMESTAMPTZ  NOT NULL DEFAULT NOW(),
  ADD COLUMN IF NOT EXISTS updated_at TIMESTAMPTZ  NOT NULL DEFAULT NOW();

-- Preenchimento de UUID nulos + NOT NULL + índice único
DO $$
BEGIN
  IF EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema='public'
      AND table_name='payment_author_registry'
      AND column_name='author_uuid'
  ) THEN
    UPDATE payment_author_registry
       SET author_uuid = gen_random_uuid()
     WHERE author_uuid IS NULL;

    BEGIN
      ALTER TABLE payment_author_registry
        ALTER COLUMN author_uuid SET NOT NULL;
    EXCEPTION WHEN others THEN
      NULL; -- já está NOT NULL
    END;

    IF NOT EXISTS (
      SELECT 1 FROM pg_indexes
      WHERE schemaname='public' AND indexname='ux_author_registry_uuid'
    ) THEN
      CREATE UNIQUE INDEX ux_author_registry_uuid
        ON payment_author_registry(author_uuid);
    END IF;
  END IF;
END$$;

-- Unicidade opcional por e-mail (se o domínio exigir)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_indexes
     WHERE schemaname='public' AND indexname='ux_author_registry_email'
  ) THEN
    CREATE UNIQUE INDEX ux_author_registry_email
      ON payment_author_registry(email);
  END IF;
END$$;

-- ========================================================================
-- 2) CONTAS PIX por autor (1:1)
-- ========================================================================
CREATE TABLE IF NOT EXISTS payment_author_accounts (
  author_id BIGINT       NOT NULL,
  pix_key   VARCHAR(255) NOT NULL
);

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname='payment_author_accounts_pkey'
  ) THEN
    ALTER TABLE payment_author_accounts
      ADD CONSTRAINT payment_author_accounts_pkey PRIMARY KEY (author_id);
  END IF;
END$$;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname='payment_author_accounts_author_id_fkey'
  ) THEN
    ALTER TABLE payment_author_accounts
      ADD CONSTRAINT payment_author_accounts_author_id_fkey
      FOREIGN KEY (author_id)
      REFERENCES payment_author_registry(id)
      ON DELETE CASCADE;
  END IF;
END$$;

-- ========================================================================
-- 3) VÍNCULO LIVRO → AUTOR (um autor por livro)
-- ========================================================================
CREATE TABLE IF NOT EXISTS payment_book_authors (
  book_id   VARCHAR(255) NOT NULL,
  author_id BIGINT       NOT NULL
);

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname='payment_book_authors_pkey'
  ) THEN
    ALTER TABLE payment_book_authors
      ADD CONSTRAINT payment_book_authors_pkey PRIMARY KEY (book_id);
  END IF;
END$$;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname='payment_book_authors_author_id_fkey'
  ) THEN
    ALTER TABLE payment_book_authors
      ADD CONSTRAINT payment_book_authors_author_id_fkey
      FOREIGN KEY (author_id)
      REFERENCES payment_author_registry(id);
  END IF;
END$$;

-- FK condicional para books(id) se a tabela existir (projeto pode não ter)
DO $$
BEGIN
  IF to_regclass('public.books') IS NOT NULL
     AND NOT EXISTS (
       SELECT 1 FROM pg_constraint WHERE conname='payment_book_authors_book_id_fkey'
     ) THEN
    ALTER TABLE payment_book_authors
      ADD CONSTRAINT payment_book_authors_book_id_fkey
      FOREIGN KEY (book_id) REFERENCES books(id) ON DELETE CASCADE;
  END IF;
END$$;

CREATE INDEX IF NOT EXISTS idx_pba_author_id ON payment_book_authors(author_id);

-- ========================================================================
-- 4) AUTOR DO SITE (singleton ativo)
-- ========================================================================
CREATE TABLE IF NOT EXISTS payment_site_author (
  id         BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name       VARCHAR(255) NOT NULL,
  email      VARCHAR(255),
  pix_key    VARCHAR(255) NOT NULL,
  active     BOOLEAN      NOT NULL DEFAULT TRUE,
  created_at TIMESTAMPTZ  NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ  NOT NULL DEFAULT NOW()
);

CREATE UNIQUE INDEX IF NOT EXISTS uq_site_author_single_active
  ON payment_site_author(active)
  WHERE active = TRUE;

-- Seed inativo seguro (apenas se tabela vazia)
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM payment_site_author) THEN
    INSERT INTO payment_site_author(name, email, pix_key, active)
    VALUES ('Autor do Site', NULL, 'PREENCHA-SUA-CHAVE-PIX-AQUI', FALSE);
  END IF;
END$$;

-- ========================================================================
-- 5) PAYOUTS (1:1 por pedido) — compatível com legado
-- ========================================================================
CREATE TABLE IF NOT EXISTS payment_payouts (
  id                   BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  order_id             BIGINT        NOT NULL,
  status               VARCHAR(20)   NOT NULL,               -- CREATED, SENT, CONFIRMED, FAILED, CANCELED
  pix_key              VARCHAR(255),                        -- permitido nulo em CREATED/FAILED
  amount               NUMERIC(12,2) NOT NULL,              -- legado
  amount_gross         NUMERIC(12,2) NOT NULL DEFAULT 0,
  amount_net           NUMERIC(12,2) NOT NULL DEFAULT 0,
  fee_percent          NUMERIC(6,3)  NOT NULL DEFAULT 0,
  fee_fixed            NUMERIC(12,2) NOT NULL DEFAULT 0,
  margin_percent       NUMERIC(6,3)  NOT NULL DEFAULT 0,
  margin_fixed         NUMERIC(12,2) NOT NULL DEFAULT 0,
  include_gateway_fees BOOLEAN       NOT NULL DEFAULT FALSE,
  min_send             NUMERIC(12,2) NOT NULL DEFAULT 0,
  created_at           TIMESTAMPTZ   NOT NULL DEFAULT NOW(),
  sent_at              TIMESTAMPTZ,
  confirmed_at         TIMESTAMPTZ,
  failed_at            TIMESTAMPTZ,
  provider_ref         VARCHAR(200),
  efi_id_envio         VARCHAR(255),
  fail_reason          VARCHAR(255)
);

-- Único por pedido (índice idempotente; evita conflito com constraints antigas)
CREATE UNIQUE INDEX IF NOT EXISTS uq_payout_order
  ON payment_payouts(order_id);

-- Status válidos
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname='chk_payment_payout_status'
  ) THEN
    ALTER TABLE payment_payouts
      ADD CONSTRAINT chk_payment_payout_status
      CHECK (status IN ('CREATED','SENT','CONFIRMED','FAILED','CANCELED'));
  END IF;
END$$;

-- Regra de pix_key (CREATED/FAILED podem ser nulos)
ALTER TABLE payment_payouts DROP CONSTRAINT IF EXISTS chk_payout_pix_key_present;
ALTER TABLE payment_payouts
  ADD CONSTRAINT chk_payout_pix_key_present
  CHECK (
    status IN ('CREATED','FAILED')
    OR (pix_key IS NOT NULL AND length(BTRIM(pix_key)) > 0)
  );

-- Índices auxiliares
CREATE INDEX IF NOT EXISTS idx_payouts_status_created ON payment_payouts(status, created_at);
CREATE INDEX IF NOT EXISTS idx_payouts_provider_ref    ON payment_payouts(provider_ref);

-- ========================================================================
-- 6) WEBHOOK EVENTS (JSON consolidado)
-- ========================================================================
CREATE TABLE IF NOT EXISTS payment_webhook_events (
  id           BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  provider     VARCHAR(20)  NOT NULL,
  external_id  VARCHAR(80)  NOT NULL,
  event_type   VARCHAR(60)  NOT NULL,
  order_ref    VARCHAR(80),
  payload_json JSONB        NOT NULL DEFAULT '{}'::jsonb,
  received_at  TIMESTAMPTZ  NOT NULL DEFAULT NOW()
);

-- Idempotência
CREATE UNIQUE INDEX IF NOT EXISTS uq_webhook_event_idem
  ON payment_webhook_events(provider, external_id, event_type);

-- Migração opcional de coluna legada 'payload' → 'payload_json'
DO $$
BEGIN
  IF EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema='public' AND table_name='payment_webhook_events' AND column_name='payload'
  ) THEN
    BEGIN
      EXECUTE $upd$
        UPDATE payment_webhook_events
           SET payload_json = COALESCE(payload::jsonb, '{}'::jsonb)
         WHERE payload IS NOT NULL
      $upd$;
    EXCEPTION WHEN others THEN
      RAISE NOTICE 'Alguns registros de payload não eram JSON válido; mantendo {}';
    END;
    -- opcional: dropar a coluna antiga
    -- EXECUTE 'ALTER TABLE payment_webhook_events DROP COLUMN payload';
  END IF;
END$$;

-- Remover default mantendo NOT NULL
ALTER TABLE payment_webhook_events
  ALTER COLUMN payload_json DROP DEFAULT;

-- ========================================================================
-- 7) CUPONS + ORDER_COUPONS (consolidados)
-- ========================================================================
CREATE TABLE IF NOT EXISTS coupons (
  id                     BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  code                   VARCHAR(50)  NOT NULL UNIQUE,
  name                   VARCHAR(200) NOT NULL,
  description            TEXT,
  discount_type          VARCHAR(20)  NOT NULL CHECK (discount_type IN ('FIXED','PERCENTAGE')),
  discount_value         NUMERIC(38,2) NOT NULL CHECK (discount_value >= 0),
  minimum_order_value    NUMERIC(38,2) NOT NULL DEFAULT 0,
  maximum_discount_value NUMERIC(38,2),
  usage_limit            INTEGER,
  usage_limit_per_user   INTEGER,
  valid_from             TIMESTAMPTZ  NOT NULL,
  valid_until            TIMESTAMPTZ,
  active                 BOOLEAN      NOT NULL DEFAULT TRUE,
  created_at             TIMESTAMPTZ  NOT NULL DEFAULT NOW(),
  updated_at             TIMESTAMPTZ  NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_coupons_code        ON coupons(code);
CREATE INDEX IF NOT EXISTS idx_coupons_active      ON coupons(active);
CREATE INDEX IF NOT EXISTS idx_coupons_valid_dates ON coupons(valid_from, valid_until);

CREATE TABLE IF NOT EXISTS order_coupons (
  id              BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  order_id        BIGINT        NOT NULL,
  coupon_id       BIGINT        NOT NULL,
  original_total  NUMERIC(38,2) NOT NULL,
  discount_amount NUMERIC(38,2) NOT NULL,
  final_total     NUMERIC(38,2) NOT NULL,
  created_at      TIMESTAMPTZ   NOT NULL DEFAULT NOW(),
  CONSTRAINT order_coupons_unique UNIQUE (order_id, coupon_id)
);

-- FKs idempotentes
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname='order_coupons_order_id_fkey'
  ) THEN
    ALTER TABLE order_coupons
      ADD CONSTRAINT order_coupons_order_id_fkey
      FOREIGN KEY (order_id) REFERENCES orders(id) ON DELETE CASCADE;
  END IF;
END$$;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname='order_coupons_coupon_id_fkey'
  ) THEN
    ALTER TABLE order_coupons
      ADD CONSTRAINT order_coupons_coupon_id_fkey
      FOREIGN KEY (coupon_id) REFERENCES coupons(id) ON DELETE CASCADE;
  END IF;
END$$;

CREATE INDEX IF NOT EXISTS idx_order_coupons_order_id ON order_coupons(order_id);
CREATE INDEX IF NOT EXISTS idx_order_coupons_coupon_id ON order_coupons(coupon_id);

-- Comentários
COMMENT ON TABLE  coupons IS 'Tabela de cupons de desconto do e-commerce';
COMMENT ON COLUMN coupons.discount_type IS 'FIXED (valor) ou PERCENTAGE (percentual)';
COMMENT ON COLUMN coupons.discount_value IS 'Valor do desconto em moeda (FIXED) ou percentual (PERCENTAGE)';
COMMENT ON TABLE  order_coupons IS 'Histórico de cupons aplicados em pedidos';

-- Cupom padrão idempotente
INSERT INTO coupons (code, name, description, discount_type, discount_value, minimum_order_value, valid_from, active)
VALUES ('DESCONTO10','Desconto R$ 15,00','Cupom de desconto fixo de R$ 15,00','FIXED', 15.00, 0, NOW(), TRUE)
ON CONFLICT (code) DO UPDATE
SET name = EXCLUDED.name,
    description = EXCLUDED.description,
    discount_type = EXCLUDED.discount_type,
    discount_value = EXCLUDED.discount_value,
    minimum_order_value = EXCLUDED.minimum_order_value,
    updated_at = NOW(),
    active = TRUE;

-- ========================================================================
-- 8) AJUSTES EM LEGADO (tipos)
-- ========================================================================
ALTER TABLE IF EXISTS books
  ALTER COLUMN description SET DATA TYPE TEXT;

-- ========================================================================
-- 9) TRIGGERS DE updated_at (só se a função existir; repeatables podem reforçar)
-- ========================================================================
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_proc WHERE proname='tg_set_updated_at') THEN
    -- payment_site_author
    IF to_regclass('public.payment_site_author') IS NOT NULL
       AND NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='trg_payment_site_author_updated_at') THEN
      CREATE TRIGGER trg_payment_site_author_updated_at
        BEFORE UPDATE ON payment_site_author
        FOR EACH ROW EXECUTE FUNCTION tg_set_updated_at();
    END IF;

    -- payment_author_registry
    IF to_regclass('public.payment_author_registry') IS NOT NULL
       AND NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='trg_payment_author_registry_updated_at') THEN
      CREATE TRIGGER trg_payment_author_registry_updated_at
        BEFORE UPDATE ON payment_author_registry
        FOR EACH ROW EXECUTE FUNCTION tg_set_updated_at();
    END IF;
  END IF;
END$$;
