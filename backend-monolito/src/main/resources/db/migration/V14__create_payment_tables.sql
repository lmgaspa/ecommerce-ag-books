-------------------------------------------------------------------------------
-- 1. Função utilitária usada pelo gatilho (trigger) pra atualizar updated_at
-------------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION tg_set_updated_at()
RETURNS trigger AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


-------------------------------------------------------------------------------
-- 2. payment_author_registry
--    - Cadastro de autores que recebem repasse
--    - Usa sequence manual (não identity)
-------------------------------------------------------------------------------

CREATE SEQUENCE IF NOT EXISTS payment_author_registry_id_seq;

CREATE TABLE IF NOT EXISTS payment_author_registry (
    id     BIGINT NOT NULL DEFAULT nextval('payment_author_registry_id_seq'::regclass),
    name   VARCHAR(255) NOT NULL,
    email  VARCHAR(255),
    CONSTRAINT payment_author_registry_pkey PRIMARY KEY (id)
);

ALTER SEQUENCE payment_author_registry_id_seq
    OWNED BY payment_author_registry.id;


-------------------------------------------------------------------------------
-- 3. payment_author_accounts
--    - Chave PIX / conta de recebimento por autor
-------------------------------------------------------------------------------

CREATE TABLE IF NOT EXISTS payment_author_accounts (
    author_id BIGINT NOT NULL,
    pix_key   VARCHAR(255) NOT NULL,
    CONSTRAINT payment_author_accounts_pkey PRIMARY KEY (author_id),
    CONSTRAINT payment_author_accounts_author_id_fkey
        FOREIGN KEY (author_id)
        REFERENCES payment_author_registry(id)
        ON DELETE CASCADE
);


-------------------------------------------------------------------------------
-- 4. payment_book_authors
--    - Liga um livro a um autor cadastrado em payment_author_registry
--    - book_id referencia books(id)
-------------------------------------------------------------------------------

CREATE TABLE IF NOT EXISTS payment_book_authors (
    book_id   VARCHAR(255) NOT NULL,
    author_id BIGINT       NOT NULL,
    CONSTRAINT payment_book_authors_pkey PRIMARY KEY (book_id),
    CONSTRAINT payment_book_authors_author_id_fkey
        FOREIGN KEY (author_id)
        REFERENCES payment_author_registry(id),
    CONSTRAINT payment_book_authors_book_id_fkey
        FOREIGN KEY (book_id)
        REFERENCES books(id)
        ON DELETE CASCADE
);


-------------------------------------------------------------------------------
-- 5. payment_site_author
--    - "dono do site" / recebedor global
--    - Só pode existir UM ativo (índice único parcial)
--    - Tem gatilho pra atualizar updated_at em UPDATE
-------------------------------------------------------------------------------

CREATE SEQUENCE IF NOT EXISTS payment_site_author_id_seq;

CREATE TABLE IF NOT EXISTS payment_site_author (
    id         BIGINT                   NOT NULL DEFAULT nextval('payment_site_author_id_seq'::regclass),
    name       VARCHAR(255)             NOT NULL,
    email      VARCHAR(255),
    pix_key    VARCHAR(255)             NOT NULL,
    active     BOOLEAN                  NOT NULL DEFAULT TRUE,
    created_at TIMESTAMPTZ              NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ              NOT NULL DEFAULT now(),
    CONSTRAINT payment_site_author_pkey PRIMARY KEY (id)
);

ALTER SEQUENCE payment_site_author_id_seq
    OWNED BY payment_site_author.id;

-- índice único parcial equivalente a:
-- "uq_site_author_single_active" UNIQUE (active) WHERE active = true
CREATE UNIQUE INDEX IF NOT EXISTS uq_site_author_single_active
    ON payment_site_author (active)
    WHERE active = true;

-- gatilho para manter updated_at = now() em qualquer UPDATE
DROP TRIGGER IF EXISTS trg_payment_site_author_updated_at ON payment_site_author;

CREATE TRIGGER trg_payment_site_author_updated_at
BEFORE UPDATE ON payment_site_author
FOR EACH ROW
EXECUTE FUNCTION tg_set_updated_at();


-------------------------------------------------------------------------------
-- 6. payment_payouts
--    - Pagamentos PIX enviados (repasse)
--    - Controle de taxas, margens, status, timestamps de envio/confirmação/erro
--    - id é identity
--    - várias UNIQUE e CHECK constraints
-------------------------------------------------------------------------------

CREATE TABLE IF NOT EXISTS payment_payouts (
    id                   BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    amount               NUMERIC(12,2)                NOT NULL,
    confirmed_at         TIMESTAMPTZ,
    created_at           TIMESTAMPTZ                  NOT NULL DEFAULT now(),
    efi_id_envio         VARCHAR(255),
    fail_reason          VARCHAR(255),
    order_id             BIGINT                       NOT NULL,
    pix_key              VARCHAR(140)                 NOT NULL,
    sent_at              TIMESTAMPTZ,
    status               VARCHAR(20)                  NOT NULL,
    amount_gross         NUMERIC(12,2)                NOT NULL DEFAULT 0,
    fee_percent          NUMERIC(6,3)                 NOT NULL DEFAULT 0,
    fee_fixed            NUMERIC(12,2)                NOT NULL DEFAULT 0,
    margin_percent       NUMERIC(6,3)                 NOT NULL DEFAULT 0,
    margin_fixed         NUMERIC(12,2)                NOT NULL DEFAULT 0,
    include_gateway_fees BOOLEAN                      NOT NULL DEFAULT FALSE,
    amount_net           NUMERIC(12,2)                NOT NULL DEFAULT 0,
    min_send             NUMERIC(12,2)                NOT NULL DEFAULT 0,
    provider_ref         VARCHAR(200),
    failed_at            TIMESTAMPTZ,
    --
    -- UNIQUE CONSTRAINTS exatamente como no Heroku
    CONSTRAINT uk7t6fnjvtb6cloqiou1acevhdt UNIQUE (efi_id_envio),
    CONSTRAINT uq_payout_order UNIQUE (order_id),
    --
    -- CHECK CONSTRAINTS exatamente como no Heroku
    CONSTRAINT chk_payout_pix_key_present CHECK (
        (
            status::text = ANY (
                ARRAY[
                    'CREATED'::character varying,
                    'FAILED'::character varying
                ]::text[]
            )
        )
        OR (
            pix_key IS NOT NULL
            AND length(TRIM(BOTH FROM pix_key)) > 0
        )
    ),
    CONSTRAINT payment_payouts_status_check CHECK (
        status::text = ANY (
            ARRAY[
                'CREATED'::character varying,
                'SENT'::character varying,
                'CONFIRMED'::character varying,
                'FAILED'::character varying,
                'CANCELED'::character varying
            ]::text[]
        )
    )
);

-- Observação: no Heroku não apareceu FK em order_id,
-- então aqui eu NÃO criei FK pra orders.id de propósito
-- (mantém compatível com produção e evita erro local).


-------------------------------------------------------------------------------
-- 7. payment_webhook_events
--    - Logs de webhooks do provedor de pagamento (Pix/cobrança etc)
--    - payload e payload_json são jsonb
--    - Tem UNIQUE duplicated (sim, existem duas UNIQUE iguais em produção)
-------------------------------------------------------------------------------

CREATE TABLE IF NOT EXISTS payment_webhook_events (
    id           BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    event_type   VARCHAR(60)        NOT NULL,
    external_id  VARCHAR(80)        NOT NULL,
    order_ref    VARCHAR(80),
    payload      JSONB              NOT NULL,
    provider     VARCHAR(20)        NOT NULL,
    received_at  TIMESTAMPTZ        NOT NULL,
    payload_json JSONB              NOT NULL,
    CONSTRAINT uk7a5iral4dtw1f4s6ugxumj45t UNIQUE (provider, external_id, event_type),
    CONSTRAINT uq_webhook_event_idem UNIQUE (provider, external_id, event_type)
);
